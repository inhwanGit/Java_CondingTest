[스택(Stack)]
  - 한 쪽 방향에서만 데이터의 삽입과 삭제가 이루어지는 자료구조이다.
  - 선입후출(First In, Last Out:FILO), 후입선출(Last In, First Out: LIFO) 구조를 가진다.

  [java lib - 스택(stack) 관련 메소드]
  push(E item) : 해당 item을 stack의 top에 삽입
  pop() : stack의 top에 있는 item을 삭제하고 해당 item을 반환
  peek() : stack의 top에 있는 item을 삭제하지않고 해당 item을 반환
  isEmpty() : stack이 비어있으면 true를 반환하고 그렇지 않으면 false를 반환
  search(Object o) : 해당 Object의 위치를 반환, stack의 top 위치는 1, 해당 Object가 없으면 -1을 반환
  size() : stack의 크기 출력
  clear() : stack 초기화

 [활용]
 - 깊이 우선 탑색(DFS, Depth-First Search) 구현 (dfs 구현으로 스택이나 재귀함수을 이용하는데 재귀함수를 이용한 구현이 더 쉽고 직관적이다.)

[큐(queue)]
  - 먼저 넣은 데이터가 먼저 나오는 자료구조.
  - 선입선출(First In, First Out:FIFO), 후입후출(Last In, Last Out: LILO) 구조를 가진다.
  [큐(queue)는 Java에서 LikedList 클래스로 Queue를 인스턴스화 하여 사용한다.]
  [java lib - 큐(queue) 구현(LikedList) 관련 메소드]
  add(data) : queue에 데이터 삽입
  poll() : queue에서 데이터 확인 및 제가
  peek() : queue에서 데이터 확인
  size() : queue 크기 출력
  clear() : queue 초기화

  [활용]
  - 넓이 우선 탑색(BFS, Breath-First Search) 구현
  - 처리해야할 노드의 리스트를 저장하는 용도로 큐(Queue)를 사용한다.
  - 노드를 하나 처리할 때마다 해당 노드와 인접한 노드들을 큐에 다시 저장한다.
  - 노드를 접근한 순서대로 처리할 수 있다.

  너비 우선 탐색(Breadth First Searc, BFS)
 - 너비 우선 탐색은 트리나 그래프를 탐색하는 알고리즘 중 하나로, 시작 정점에서 시작하여 인접한 정점을 먼저 탐색하는 방법이다.
 - bfs는 최소비용 경로를 찾는 데에 장점이 있으며, queue를 이용해서 구현한다.

 <bfs 구현 단계>
 1. 시작점을 큐에 넣는다.
 2. 큐에서 한 점을 꺼낸 후 기준점으로 삼는다.
 3. 기준점이 목적지이면 탐색을 종료한다.
 4. 그렇지 않은 경우 기준점에서 갈 수 있는 다음 정점들을 큐에 넣는다.
 5. 큐에 원소가 없을 때까지 2단계로 돌아가 반복한다.

  (입력예시)
  1 // 입력 횟수
  7 6 // 정점 개수, 간선 수
  1 7 // 시작점, 도착점
  1 2 // 연결 정보
  2 4
  2 5
  1 3
  3 6
  6 7

 <재귀함수>
 함수 내부에서 ‘자기 자신을 호출’하는 함수를 의미합니다. 이를 통해서 함수가 자신을 반복적으로 호출하면서 원하는 결과를 도출할 수 있습니다.

백트래킹
백트래킹은 해를 찾아가는 도중에 지금의 경로가 해가 될 거 같지 않으면, 더 이상 깊이 들어가지 않고 이전 단계로 다시 돌아간다. 이를 가지치기라고 하는데, 불필요한 부분을 쳐내고 최대한 올바른 방향으로 나아가는 방식이기 때문에 DFS보다 효율적이다. 하지만, N!의 경우의 수를 가진 최악의 문제에서는 여전히 지수함수의 시간복잡도가 걸려서 처리가 불가능할 수도 있다. 따라서, 가지치기를 얼마나 잘하느냐에 따라 효율성이 결정된다.

정리하자면, 백트래킹은 모든 가능한 경우의 수 중에서 특정한 조건을 만족하는 경우만 살펴보는 것이다! 즉, 답이 될만한 가능성이 없으면 더 이상 탐색을 진행하지 않고 가지치기를 하면서 최적해를 구하는 것이다.

주로 문제풀이에서는 DFS 등으로 모든 경우의 수를 탐색하는 과정에서, 조건문을 걸어서 답이 절대로 될 수 없는 상황을 정의하고, 그런 상황일 때는 탐색을 중지시킨 뒤 다시 이전 단계로 돌아가서 다른 경우를 탐색하도록 구현할 수 있다.

한 가지 예시로 n개 중에 순서를 고려하지 않고 r개를 선택하는 조합 코드를 보자. DFS로 깊이 있게 탐색하다가 r개를 모두 선택한 경우에는 현재 가지에 대한 탐색을 종료한다. 그리고 다음 경우의 수에 대한 탐색을 위해 상태를 복구하고 다시 재귀 호출을 반복한다. 따라서 조합도 백트래킹의 예시라고 볼 수 있다.

다이나믹 프로그래밍은 이름은 뭔가 거창하지만 개념은 간단한데
바로 최종 결과를 얻기 위해 필요한 하위 데이터를 계속 저장해서 상위 문제를 해결하는 방법이다
핵심은 하위 데이터를 계속 저장한다는 점이다
